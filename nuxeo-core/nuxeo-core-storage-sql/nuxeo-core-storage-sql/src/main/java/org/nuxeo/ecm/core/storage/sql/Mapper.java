/*
 * (C) Copyright 2007-2010 Nuxeo SA (http://nuxeo.com/) and contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser General Public License
 * (LGPL) version 2.1 which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * Contributors:
 *     Florent Guillaume
 */

package org.nuxeo.ecm.core.storage.sql;

import java.io.Serializable;
import java.util.List;
import java.util.Map;

import javax.transaction.xa.XAResource;

import org.nuxeo.ecm.core.api.IterableQueryResult;
import org.nuxeo.ecm.core.query.QueryFilter;
import org.nuxeo.ecm.core.storage.PartialList;
import org.nuxeo.ecm.core.storage.StorageException;

/**
 * A {@link Mapper} maps fragments to and from the database.
 */
public interface Mapper extends XAResource {

    void close();

    // TODO
    int getTableSize(String tableName);

    /**
     * Creates the necessary structures in the database.
     */
    // TODO
    void createDatabase() throws StorageException;

    /*
     * ----- Cluster -----
     */

    /**
     * Informs the cluster that this node exists.
     */
    void createClusterNode() throws StorageException;

    /**
     * Removes this node from the cluster.
     */
    void removeClusterNode() throws StorageException;

    /**
     * Inserts the invalidation rows for the other cluster nodes.
     */
    void insertClusterInvalidations(Invalidations invalidations)
            throws StorageException;

    /**
     * Gets the invalidations from other cluster nodes.
     */
    Invalidations getClusterInvalidations() throws StorageException;

    /**
     * Gets the root id for a given repository, if registered.
     *
     * @param repositoryId the repository id, usually 0
     * @return the root id, or null if not found
     */
    Serializable getRootId(Serializable repositoryId) throws StorageException;

    /**
     * Records the newly generated root id for a given repository.
     *
     * @param repositoryId the repository id, usually 0
     * @param id the root id
     */
    void setRootId(Serializable repositoryId, Serializable id)
            throws StorageException;

    /**
     * Inserts a new {@link SimpleFragment} in the storage. Depending on the
     * type, the id may be generated by the database (in which case it must not
     * be provided in the {@link SimpleFragment}), or already assigned (which is
     * the case for non-main tables).
     *
     * @param row the row
     * @return the id (generated or not)
     */
    Serializable insertSingleRow(SimpleFragment row) throws StorageException;

    /**
     * Inserts a new {@link CollectionFragment} in the storage.
     *
     * @param fragment the fragment
     */
    void insertCollectionRows(CollectionFragment fragment)
            throws StorageException;

    /**
     * Gets the state for a {@link SimpleFragment} from the database, given its
     * table name and id. If the row doesn't exist, {@code null} is returned.
     *
     * @param tableName the type name
     * @param id the id
     * @param context the persistence context to which the read row is tied
     * @return the map, or {@code null}
     */
    Map<String, Serializable> readSingleRowMap(String tableName,
            Serializable id, Context context) throws StorageException;

    /**
     * Gets the states for a list of {@link SimpleFragment}s from the database,
     * given the table name and their ids.
     *
     * @param tableName the type name
     * @param ids the ids
     * @param context the persistence context to which the read rows are tied
     * @return the map of fragment id to fragment values map
     */
    Map<Serializable, Map<String, Serializable>> readMultipleRowMaps(
            String tableName, List<Serializable> ids, Context context)
            throws StorageException;

    /**
     * Reads the hierarchy {@link SimpleFragment} for a child, given its parent
     * id and the child name.
     *
     * @param parentId the parent id
     * @param childName the child name
     * @param complexProp whether to get complex properties ({@code true}) or
     *            regular children({@code false})
     * @param context the persistence context to which the read row is tied
     * @return the child hierarchy row, or {@code null}
     */
    SimpleFragment readChildHierRow(Serializable parentId, String childName,
            boolean complexProp, Context context) throws StorageException;

    /**
     * Reads the hierarchy {@link SimpleFragment}s for all the children of
     * parent.
     * <p>
     * Rows that are already known to the persistence context are returned from
     * it, so as to never have duplicate objects for the same row.
     * <p>
     * Depending on the boolean {@literal complexProp}, only the complex
     * properties or only the regular children are returned.
     *
     * @param parentId the parent id
     * @param complexProp whether to get complex properties ({@code true}) or
     *            regular children({@code false})
     * @param context the persistence context to which the read rows are tied
     * @return the child hierarchy rows, or {@code null}
     */
    List<SimpleFragment> readChildHierRows(Serializable parentId,
            boolean complexProp, Context context) throws StorageException;

    /**
     * Creates an empty collection fragment given a table name and id.
     *
     * @param id the id
     * @param context the persistence context to which the empty fragment is
     *            tied
     * @return the new collection fragment
     */
    CollectionFragment makeEmptyCollectionRow(Serializable id,
            Context context);

    /**
     * Gets an array for a {@link CollectionFragment} from the database, given
     * its table name and id. If now rows are found, an empty array is returned.
     *
     * @param id the id
     * @param context the persistence context to which the read fragment is tied
     * @return the array
     */
    Serializable[] readCollectionArray(Serializable id, Context context)
            throws StorageException;

    /**
     * Reads a collection fragment from the database, given its table name and
     * id.
     *
     * @param id the id
     * @param context the persistence context to which the read fragment is tied
     * @return the collection fragment
     * @throws StorageException
     */
    CollectionFragment readCollectionRow(Serializable id, Context context)
            throws StorageException;

    /**
     * Reads several collection fragments, given a table name and the ids.
     *
     * @param ids the ids
     * @param context the persistence context to which the read fragments are
     *            tied
     * @param fragments a list to which fragments are added
     */
    void readCollectionsRows(List<Serializable> ids, Context context,
            List<Fragment> fragments) throws StorageException;

    /**
     * Updates a row in the database.
     *
     * @param row the row
     * @throws StorageException
     */
    void updateSingleRow(SimpleFragment row) throws StorageException;

    /**
     * Updates a {@link CollectionFragment} in the database.
     * <p>
     * Does a simple delete + insert for now.
     *
     * @param fragment the fragment
     * @throws StorageException
     */
    void updateCollectionRows(CollectionFragment fragment)
            throws StorageException;

    /**
     * Deletes a fragment from the database (one or several rows).
     *
     * @param fragment the fragment
     */
    void deleteFragment(Fragment fragment) throws StorageException;

    /**
     * Copies the hierarchy starting from a given fragment to a new parent with
     * a new name.
     * <p>
     * If the new parent is {@code null}, then this is a version creation, which
     * doesn't recurse in regular children.
     * <p>
     * If {@code overwriteId} and {@code overwriteMap} are passed, the copy is
     * done onto this existing node as its root (version restore) instead of
     * creating a new node in the parent.
     *
     * @param sourceId the id of fragment to copy (with children)
     * @param typeName the type of the fragment to copy (to avoid refetching
     *            known info)
     * @param destParentId the new parent id, or {@code null}
     * @param destName the new name
     * @param overwriteId when not {@code null}, the copy is done onto this
     *            existing root id
     * @param overwriteMap when overwriting, set these hierarchy columns
     * @param persistenceContext the persistence context, to invalidate
     *            fragments when overwriting
     * @return the id of the root of the copy
     * @throws StorageException
     */
    Serializable copyHierarchy(Serializable sourceId, String typeName,
            Serializable destParentId, String destName,
            Serializable overwriteId, Map<String, Serializable> overwriteMap,
            PersistenceContext persistenceContext) throws StorageException;

    /**
     * Gets the id of a version given a versionableId and a label.
     *
     * @param versionableId the versionable id
     * @param label the label
     * @param context the versions context
     * @return the id of the version, or {@code null} if not found
     * @throws StorageException
     */
    Serializable getVersionByLabel(Serializable versionableId, String label,
            Context context) throws StorageException;

    /**
     * Gets id of the last version given a versionable id.
     *
     * @param versionableId the versionable id
     * @param context the version fragment context
     * @return the id of the last version, or {@code null} if not found
     * @throws StorageException
     */
    SimpleFragment getLastVersion(Serializable versionableId, Context context)
            throws StorageException;

    /**
     * Gets the list of version fragments for all the versions having a given
     * versionable id.
     *
     * @param versionableId the versionable id
     * @param context the version fragment context
     * @return the list of version fragments
     * @throws StorageException
     */
    List<SimpleFragment> getVersions(Serializable versionableId, Context context)
            throws StorageException;

    /**
     * Finds proxies, maybe restricted to the children of a given parent.
     *
     * @param searchId the id to look for
     * @param byTarget {@code true} if the searchId is a proxy target id,
     *            {@code false} if the searchId is a versionable id
     * @param parentId the parent to which to restrict, if not {@code null}
     * @param context the proxies fragment context
     * @return the list of proxies fragments
     * @throws StorageException
     */
    List<SimpleFragment> getProxies(Serializable searchId, boolean byTarget,
            Serializable parentId, Context context) throws StorageException;

    /**
     * Makes a NXQL query to the database.
     *
     * @param query the query
     * @param queryFilter the query filter
     * @param countTotal if {@code true}, count the total size without
     *            limit/offset
     * @param session the current session (to resolve paths)
     * @return the list of matching document ids
     * @throws StorageException
     */
    PartialList<Serializable> query(String query, QueryFilter queryFilter,
            boolean countTotal, Session session) throws StorageException;

    /**
     * Makes a query to the database and returns an iterable (which must be
     * closed when done).
     *
     * @param query the query
     * @param queryType the query type
     * @param queryFilter the query filter
     * @param session the current session (to resolve paths)
     * @param params optional query-type-dependent parameters
     * @return an iterable, which <b>must</b> be closed when done
     * @throws StorageException
     */
    // queryFilter used for principals and permissions
    public IterableQueryResult queryAndFetch(String query, String queryType,
            QueryFilter queryFilter, Session session, Object... params)
            throws StorageException;

    /*
     * ----- read ACLs methods -----
     */

    void updateReadAcls() throws StorageException;

    void rebuildReadAcls() throws StorageException;

}
